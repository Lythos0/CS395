Pushdown Automata
M(Q,S,G,d,q_0,F) where 
1. Q is a finite set of states
2. S is a finite set of symbols
3. G is a finite set of stack symbols
4. d Q x S_. x G_. => P(Q x G_.) 
5. q_0 is the start states
6. F is a finite set of accepting states

 a, b -> c
 if the current state sees the symbol a and the top of the stack is the symbol b,
 the current state to the new state, pop the top of the stack, and push c to the
 top of the stack. 

 a = . represents epsilon-move
 b = . represents do not pop stack
 c = . represents do not push to the stack

 L = {w| |w| = 2}

 Q = {a,b,c}
 S = {0,1}
 G = {0}
 d = {(a,0,.,b,.),(a,1,.,b,.),(b,0,.,c,.),(b,1,.,c,.)}
 q_0 = a
 F = {c}

 00
 ({(a,.)},{(b,.)},{(c,.)}) accepted

 110
 ({(a,.)},{(b,.)},{(c,.)},{}) rejected

 L = {0^n1^n,n >= 0}

 1. Q = {a,b,c,d}
 2. S = {0,1}
 3. G = {$,i}
 4. d = {(a,.,.,b,$),(b,0,.,b,i),(b,.,.,c,.),(c,1,i,c,.),(c,.,$,d,.)}
 5. q_0 = a
 6. F = {d}

(a,.,.,b,$) = if state a does not read a symbol and does not pop the stack, it goes to state b and pushes $ to the top of the stack
(b,0,.,b,i) = if state b sees a 0 and does not pop the stack, it goes to state b and pushes i to the top of the stack
(b,.,.,c,.) = if state b does not read a symbol and does not pop the stack, it goes to state c and does not push to the stack
(c,1,i,c,.) = if state c sees a 1 and pops an i from the top of the stack, it goes to state c and does not push to the stack
(c,.,$,d,.) = if state c does not read a symbol and pops a $ from the top of the stack, it goes to state d and does not push to th stackrm   
 0011
 ({(a,.),(b,$),(c,$),(d,.)},{(b,i$),(c,i$)},{(b,ii$),(c,ii$)},{(c,i$)},{(c,$),(d,.)})